<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>FBB Visualizer</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true}); // Generate the BABYLON 3D engine

		//const ModelURL = "https://raw.githubusercontent.com/sylvain-d-guimond/public_content/main/cobra.glb";
		const ModelURL = "../Models/Plane.glb";
		const EnvURL = "../Models/Scene_Setup_Environment.glb";
		var cameras = [];

		const createScene = function () {

			const scene = new BABYLON.Scene(engine);
			scene.environmentTexture = new BABYLON.CubeTexture("../Models/autoshop.env", scene);

			var assetsManager = new BABYLON.AssetsManager(scene);
			var envTask = assetsManager.addMeshTask("environment task", "", EnvURL, "");
			
			assetsManager.load();

			loadAndUseModel(scene, ModelURL);
			//loadAndUseModel(scene, EnvURL);
			
			//Needs an initial camera or Babylon complains, but still runs
			const cam = new BABYLON.ArcRotateCamera("camera",-Math.PI / 4,Math.PI / 2.5,10,BABYLON.Vector3(0,1,0), scene);
			cam.attachControl(canvas, true);

			const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
			var spotLight = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), Math.PI / 3, 2, scene);

			//Add skybox
			/*var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000.0 }, scene);
			skybox.isPickable = false;
			var skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
			skyboxMaterial.backFaceCulling = false;
			skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../Models/skybox/autoshop", scene);
			skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
			skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
			skybox.material = skyboxMaterial;*/
			scene.clearColor = new BABYLON.Color3(0.85, 0.8, 0.77);

			//Add Postprocessing
			pipeline = new BABYLON.DefaultRenderingPipeline("renderingPipeline", true);

			//bloom
			pipeline.bloomEnabled = true;
			pipeline.bloomThreshold = 2;
			pipeline.bloomWeight = 0.3;
			pipeline.bloomKernel = 64;
			pipeline.bloomScale = 0.5;

			//tonemapping
			pipeline.imageProcessing.toneMappingEnabled = true;
			pipeline.imageProcessing.contrast = 1.5;
			pipeline.imageProcessing.exposure = 1;

			//MSAA
			//pipeline.samples = 4;
			
			//Vignette
			postProcess = new BABYLON.ImageProcessingPostProcess("processing", 1.0, cam);
			postProcess.vignetteWeight = 10;
			postProcess.vignetteStretch = 2;
			postProcess.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
			postProcess.vignetteEnabled = true;



			//Interaction
			scene.onPointerDown = (evt, pickinfo) => {
				console.log("pickinfo", pickinfo);
				if (pickinfo.hit)
					//alert(pickinfo.pickedMesh.name)
					processClick(pickinfo.pickedMesh);
			};
			
			//Environment loaded
			envTask.onSuccess = function (task) {
				scene.getMeshByName("GEO_Floor").isPickable = false;
			}

			return scene;
		}

		const loadAndUseModel = (scene, url) => {
			let loadedCamera = null;
			BABYLON.SceneLoader.OnPluginActivatedObservable.addOnce(loader => {
				if (loader.name === 'gltf') {

					//Import cameras from GLTF
					loader.onCameraLoadedObservable.addOnce((camera) => {
						console.log('onCameraLoaded', camera);

						//Convert loaded camera to ArcRotateCamera
						//TODO: find a better way that doesn't create an extra camera
						const arcCamera = new BABYLON.ArcRotateCamera(
							camera.name,
						//TODO: get actual proper initial angle from camera
							-Math.PI / 4,
							Math.PI / 2.5,
							10,
							camera.lockedTarget, scene);
						arcCamera.attachControl(canvas, true);
						loadedCamera = arcCamera;
						//loadedCamera = camera;
						pipeline.addCamera(arcCamera);
						postProcess.activate(arcCamera);
						cameras.push(arcCamera);
					})

					//Set all meshes as non-pickable by default
					loader.onMeshLoadedObservable.add((mesh) => {
						mesh.isPickable = false;
					})
				}
			})

			//Load scene
			BABYLON.SceneLoader.LoadAssetContainerAsync(url, undefined, scene).then(
				(assetContainer) => {
					assetContainer.addAllToScene();
					initCameraLimits();
					initUI();
				},
			)
		}

		//Initialize all camera limits
		const initCameraLimits = () => {
			setCameraBounds("CamExt01", -Math.PI, 0, 0.5, 1.5, 5, 20);

			//Default Camera
			setActiveCamera("CamExt01");
		}

		const setCameraBounds = (name, xMin, xMax, yMin, yMax, zMin, zMax) => {
			var camera = cameras.filter(cam => {
				return cam.name === name;
			})[0];

			console.log("Set camera bounds: ", camera);
			camera.upperRadiusLimit = zMax;
			camera.lowerRadiusLimit = zMin;
			camera.upperBetaLimit = yMax;
			camera.lowerBetaLimit = yMin;
			camera.upperAlphaLimit = xMax;
			camera.lowerAlphaLimit = xMin;
			camera.pinchPrecision = 500;
			camera.wheelPrecision = 50;
			camera.minZ = 0.01;
		}

		const setActiveCamera = (cameraName) => {
			var camera = cameras.filter(cam => {
				return cam.name === cameraName;
			})[0];

			scene.activeCamera = camera;
		}

		const initUI = () => {
			var control1 = scene.getMeshByName("Sphere");
			var control2 = scene.getMeshByName("Sphere.001");
			var control3 = scene.getMeshByName("Sphere.002");
			var control4 = scene.getMeshByName("Sphere.003");
			var control5 = scene.getMeshByName("Sphere.004");
			var control6 = scene.getMeshByName("Sphere.005");
			var control7 = scene.getMeshByName("Sphere.006");

			control1.isPickable = control2.isPickable = control3.isPickable = control4.isPickable =
			control5.isPickable = control6.isPickable = control7.isPickable = true;
			
			var switchCamInt = scene.getMeshByName("Switch_CamInt01");
			switchCamInt.isPickable = true;
		}
		
		const processClick = (clickedMesh) => {
			if (clickedMesh.name.includes("Switch_")){
				setActiveCamera(clickedMesh.name.replace("Switch_",""));
			}
			
			if (clickedMesh.name.includes("Sphere")){
				setColor(clickedMesh.material)
			}
		}

		const setColor = (material) => {
			var body = scene.getMeshByName("GEO_Plane_Body")

			body.material = material;
		}

        const scene = createScene(); //Call the createScene function

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>