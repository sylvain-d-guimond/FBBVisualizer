<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>FBB Visualizer</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/vue"></script>
		<script src="CameraManager.js"></script>
		<script src="VariantManager.js"></script>
		<script src="DebugUI.js"></script>
		<!--<script src="FBBUI.js"></script>
		<link href="FBBUI.css" rel="stylesheet">-->
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true}); // Generate the BABYLON 3D engine

		const configURL = "config_cobra.json";
		//const configURL = "config.json";
		let scene = "";
		var config = "";
		var switches = [];
		var cameraManager;
		var variantManager;

		const createScene = function () {

			const scene = new BABYLON.Scene(engine);
			scene.environmentTexture = new BABYLON.CubeTexture("../Models/autoshop.env", scene);

			//Needs an initial camera or Babylon complains, but still runs
			const cam = new BABYLON.ArcRotateCamera("camera", -Math.PI / 4, Math.PI / 2.5, 10, BABYLON.Vector3(0, 1, 0), scene);

			const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
			var spotLight = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), Math.PI / 3, 2, scene);

			scene.clearColor = new BABYLON.Color3(0.85, 0.8, 0.77);

			//Add Postprocessing
			pipeline = new BABYLON.DefaultRenderingPipeline("renderingPipeline", true);

			//bloom
			pipeline.bloomEnabled = true;
			pipeline.bloomThreshold = 2;
			pipeline.bloomWeight = 0.3;
			pipeline.bloomKernel = 64;
			pipeline.bloomScale = 0.5;

			//tonemapping
			pipeline.imageProcessing.toneMappingEnabled = true;
			pipeline.imageProcessing.contrast = 1.5;
			pipeline.imageProcessing.exposure = 1;

			//MSAA
			//pipeline.samples = 4;

			//Vignette
			postProcess = new BABYLON.ImageProcessingPostProcess("postProcessing", 1.0, cam);
			postProcess.vignetteWeight = 10;
			postProcess.vignetteStretch = 2;
			postProcess.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
			postProcess.vignetteEnabled = true;

			cameraManager = new CameraManager(pipeline, postProcess, scene);
			variantManager = new VariantManager(config);

			var assetsManager = new BABYLON.AssetsManager(scene);
			if (config.paths.useSceneLoader){
				console.log("Using scene loader");
				assetsManager.autoHideLoadingUI = false;
				var extTask = assetsManager.addMeshTask("exterior task", "", config.paths.modelExtURL, "");
				var envTask = assetsManager.addMeshTask("environment task", "", config.paths.envURL, "");
				var intTask = assetsManager.addMeshTask("interior task", "", config.paths.modelIntURL, "");

				//Exterior loaded
				extTask.onSuccess = function (task){
					console.log("Exterior loaded");
					setMeshesNotClickable(task);
				}

				//Environment loaded
				envTask.onSuccess = function (task) {
					setMeshesNotClickable(task);
				}

				//Interior loaded
				intTask.onSuccess = function (task) {
					setMeshesNotClickable(task);
					engine.hideLoadingUI();
				}
			}

			loadAndUseModel(scene, config.paths.camerasURL);
			assetsManager.load();

			//Interaction
			scene.onPointerDown = (evt, pickinfo) => {
				//console.log("pickinfo", pickinfo);
				if (pickinfo.hit){
					console.log("RayCast Hit:", pickinfo.pickedMesh.name);
					processClick(pickinfo.pickedMesh);
				}
			};
			
			//var UI = new FBBUI(4);

			return scene;
		}

		const loadAndUseModel = (scene, url) => {
			let loadedCamera = null;
			BABYLON.SceneLoader.OnPluginActivatedObservable.addOnce(loader => {
				if (loader.name === 'gltf') {

					//Import cameras from GLTF
					loader.onCameraLoadedObservable.add((camera) => {
						if (!cameraManager.sceneCameras.includes(camera)){
							cameraManager.sceneCameras.push(camera);
						}

						//Convert loaded camera to ArcRotateCamera
						//TODO: find a better way that doesn't create an extra camera
						const arcCamera = new BABYLON.ArcRotateCamera(
							camera.name,
							//TODO: get actual proper initial angle from camera
							-Math.PI / 4,
							Math.PI / 2.5,
							10,
							camera.lockedTarget, scene);
						cameraManager.checkAndAddCamera(arcCamera);
					})

					//Set all meshes as non-pickable by default
					loader.onMeshLoadedObservable.add((mesh) => {
						mesh.isPickable = false;

						if (mesh.name.includes("Switch_")){
							console.log("Found switch: ", mesh.name);
							mesh.isPickable = true;
							switches.push(mesh);
						}
					})
				}
			})

			//Load scene
			BABYLON.SceneLoader.LoadAssetContainerAsync(url, undefined, scene).then(
				(assetContainer) => {
					assetContainer.addAllToScene();
					initCameraLimits();
					pipeline.addCamera(cameraManager.flyCam);
					
					
					
					if (!config.paths.useSceneLoader){
						variantManager.discoverVariants(scene);
						engine.hideLoadingUI();
						var ui = new DebugUI();
						ui.setupUI(variantManager, cameraManager);
					}
				},
			)
		}

		const setMeshesNotClickable = (meshTask) => {
			meshTask.loadedMeshes.forEach((mesh) => {
				mesh.isPickable = false;
			});
		}

		//Initialize all camera limits
		const initCameraLimits = () => {
			cameraManager.alignCameras();
			cameraManager.setCameraBounds("CamExt01", -2*Math.PI, 2*Math.PI, 0.5, 1.5, 5, 20);
			cameraManager.setCameraBounds("CamInt01", Math.PI*0.6, Math.PI*2, 0.8, 1.5, 0.5, 0.55);
			//setCameraBounds("CamInt01", -2*Math.PI, 3*Math.PI, 0.4, 1.5, 0.5, 1.5);

			//Default Camera
			cameraManager.setActiveCamera("CamExt01");
		}

		const processClick = (clickedMesh) => {
			if (clickedMesh.name.includes("Switch_")){
				cameraManager.flyToCamera(clickedMesh.name.replace("Switch_", "").replace(".001", ""));
			}
		}

		const setColor = (material, geo) => {
			var body = scene.getMeshByName(geo)

			body.material = material;
		}
		
		const getTextFromUrl = function (url, callback, async = true) {
			var request = new XMLHttpRequest();
			request.open('GET', url, async);
			request.onreadystatechange = function () {
				if (request.readyState === 4 && request.status === 200) {
					var type = request.getResponseHeader('Content-Type');
					if (type.indexOf("text") !== 1) {
						callback(request.responseText);
					}
				}
			}
			request.onerror = function () {
				console.log("getTextFromUrl(): could not find url " + url);
			}
			request.send(null);
		}
		
		const startRenderLoop = function (){
			scene = createScene(); //Call the createScene function

			// Register a render loop to repeatedly render the scene
			engine.runRenderLoop(function () {
					if (scene && scene.activeCamera) {
						scene.render();
					}
				});

			// Watch for browser/canvas resize events
			window.addEventListener("resize", function () {
					engine.resize();
			});
		}
		
		getTextFromUrl(configURL, function (text) {
			try {
				config = JSON.parse(text);
				console.log("config loaded:", config);
				startRenderLoop();
			} catch (e) {
				console.error("JSON data of file " + configURL + " invalid", e);
			}
		});
		
    </script>
	
	<div id="ui-app"></div>
   </body>

</html>