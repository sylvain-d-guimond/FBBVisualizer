<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>FBB Visualizer</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/vue"></script>
		<script src="CameraManager.js"></script>
		<script src="VariantManager.js"></script>
		<script src="DebugUI.js"></script>
		<script src="FBBUI.js"></script>
		<!--<script src="FBBUI.js"></script>
		<link href="FBBUI.css" rel="stylesheet">-->
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true}); // Generate the BABYLON 3D engine

		//const configURL = "https://www.radfahrrad.com/index.php/s/FkXwYfgCSykKorG/download/config.json";
		const configURL = "config.json";
		let scene = "";
		var config = "";
		var switches = [];
		var cameraManager;
		var variantManager;
		var loadMgr;
		var loadTime = Date.now();

		const createScene = function () {

			const scene = new BABYLON.Scene(engine);
			scene.environmentTexture = new BABYLON.CubeTexture(config.paths.IBLURL, scene);

			//Needs an initial camera or Babylon complains, but still runs
			const cam = new BABYLON.ArcRotateCamera("camera", -Math.PI / 4, Math.PI / 2.5, 10, BABYLON.Vector3(0, 1, 0), scene);

			const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
			var spotLight = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), Math.PI / 3, 2, scene);

			scene.clearColor = new BABYLON.Color3(0.85, 0.8, 0.77);

			var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
			var skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
			skyboxMaterial.backFaceCulling = false;
			skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("img/skybox/sky", scene);
			skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
			skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
			skybox.material = skyboxMaterial;

			//Add Postprocessing
			pipeline = new BABYLON.DefaultRenderingPipeline("renderingPipeline", true);

			//bloom
			pipeline.bloomEnabled = true;
			pipeline.bloomThreshold = 2;
			pipeline.bloomWeight = 0.3;
			pipeline.bloomKernel = 64;
			pipeline.bloomScale = 0.5;

			//tonemapping
			pipeline.imageProcessing.toneMappingEnabled = true;
			pipeline.imageProcessing.contrast = 1.5;
			pipeline.imageProcessing.exposure = 1;

			//MSAA
			//pipeline.samples = 4;

			//Vignette
			postProcess = new BABYLON.ImageProcessingPostProcess("postProcessing", 1.0, cam);
			postProcess.vignetteWeight = 10;
			postProcess.vignetteStretch = 2;
			postProcess.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
			postProcess.vignetteEnabled = false;

			cameraManager = new CameraManager(pipeline, postProcess, scene);
			variantManager = new VariantManager(config);
			loadMgr = new LoadManager(finishLoading);
			loadMgr.useSceneLoader = config.paths.useSceneLoader;

			var assetsManager = new BABYLON.AssetsManager(scene);
			if (config.paths.useSceneLoader){
				console.log("Using scene loader");
				assetsManager.autoHideLoadingUI = false;
				var extTask = assetsManager.addMeshTask("exterior task", "", config.paths.modelExtURL, "");
				var envTask = assetsManager.addMeshTask("environment task", "", config.paths.envURL, "");
				var intTask = assetsManager.addMeshTask("interior task", "", config.paths.modelIntURL, "");

				//Exterior loaded
				extTask.onSuccess = function (task){
					console.log("Exterior loaded");
					setMeshesNotClickable(task);
					loadMgr.extLoaded = true;
					loadMgr.check();
				}

				//Environment loaded
				envTask.onSuccess = function (task) {
					console.log("Environment loaded");
					setMeshesNotClickable(task);
					loadMgr.envLoaded = true;
					loadMgr.check();
				}

				//Interior loaded
				intTask.onSuccess = function (task) {
					console.log("Interior loaded");
					setMeshesNotClickable(task);
					loadMgr.intLoaded = true;
					loadMgr.check();
				}
			}

			loadAndUseModel(scene, config.paths.camerasURL);
			assetsManager.load();

			//Interaction
			scene.onPointerDown = (evt, pickinfo) => {
				//console.log("pickinfo", pickinfo);
				if (pickinfo.hit){
					console.log("RayCast Hit:", pickinfo.pickedMesh.name);
					processClick(pickinfo.pickedMesh);
				}
			};
			
			//var UI = new FBBUI(4);

			return scene;
		}

		const loadAndUseModel = (scene, url) => {
			let loadedCamera = null;
			BABYLON.SceneLoader.OnPluginActivatedObservable.addOnce(loader => {
				if (loader.name === 'gltf') {

					//Import cameras from GLTF
					loader.onCameraLoadedObservable.add((camera) => {
						console.log("Found camera:", camera.name, camera);
						if (!cameraManager.sceneCameras.includes(camera)){
							cameraManager.sceneCameras.push(camera);
						}

						//Convert loaded camera to ArcRotateCamera
						//TODO: find a better way that doesn't create an extra camera
						const arcCamera = new BABYLON.ArcRotateCamera(
							camera.name,
							//TODO: get actual proper initial angle from camera
							-Math.PI / 4,
							Math.PI / 2.5,
							10,
							camera.lockedTarget, scene);
						cameraManager.checkAndAddCamera(arcCamera);
					})

					//Set all meshes as non-pickable by default
					loader.onMeshLoadedObservable.add((mesh) => {
						mesh.isPickable = false;

						if (mesh.name.includes("Switch_")){
							//console.log("Found switch: ", mesh.name);
							mesh.isPickable = true;
							switches.push(mesh);
						}
					})
				}
			})

			//Load scene
			BABYLON.SceneLoader.LoadAssetContainerAsync(url, undefined, scene).then(
				(assetContainer) => {
					assetContainer.addAllToScene();
					initCameraLimits();
					pipeline.addCamera(cameraManager.flyCam);
							
					console.log("Set camera limits...");
					getTextFromUrl(config.paths.cameraLimitsURL, function (text){ 
						cameraManager.loadCameraLimits(text);
						loadMgr.camsLoaded = true;
						loadMgr.check();
					});
				},
			)
		}

		const finishLoading = function(){
			console.log("Discover variants...");
			variantManager.discoverVariants(scene);
			//console.log("Show Debug UI");
			//var ui = new DebugUI();
			//ui.setupUI(variantManager, cameraManager);
			console.log("Show UI");
			var fbbui = new FBBUI();
			fbbui.setupUI(variantManager, cameraManager);
			engine.hideLoadingUI();
			console.log("Finished loading in", Date.now()-loadTime, "ms");
		}

		const setMeshesNotClickable = (meshTask) => {
			meshTask.loadedMeshes.forEach((mesh) => {
				mesh.isPickable = false;
			});
		}

		//Initialize all camera limits
		const initCameraLimits = () => {
			cameraManager.alignCameras();
			//cameraManager.setCameraBounds("CamExt01", -2*Math.PI, 2*Math.PI, 0.5, 1.5, 5, 20);
			//cameraManager.setCameraBounds("CamInt01", Math.PI*0.6, Math.PI*2, 0.8, 1.5, 0.5, 0.55);
			//setCameraBounds("CamInt01", -2*Math.PI, 3*Math.PI, 0.4, 1.5, 0.5, 1.5);

			//Default Camera
			cameraManager.setActiveCamera("CamExt01");
		}

		const processClick = (clickedMesh) => {
			if (clickedMesh.name.includes("Switch_")){
				cameraManager.flyToCamera(clickedMesh.name.replace("Switch_", "").replace(".001", ""));
			}
		}

		const setColor = (material, geo) => {
			var body = scene.getMeshByName(geo)

			body.material = material;
		}
		
		const getTextFromUrl = function (url, callback, async = true) {
			var request = new XMLHttpRequest();
			request.open('GET', url, async);
			request.onreadystatechange = function () {
				if (request.readyState === 4 && request.status === 200) {
					var type = request.getResponseHeader('Content-Type');
					if (type.indexOf("text") !== 1) {
						callback(request.responseText);
					}
				}
			}
			request.onerror = function () {
				console.log("getTextFromUrl(): could not find url " + url);
			}
			request.send(null);
		}
		
		const startRenderLoop = function (){
			scene = createScene(); //Call the createScene function

			// Register a render loop to repeatedly render the scene
			engine.runRenderLoop(function () {
					if (scene && scene.activeCamera) {
						scene.render();
					}
				});

			// Watch for browser/canvas resize events
			window.addEventListener("resize", function () {
					engine.resize();
			});
		}

		//Some load manager
		function LoadManager(loadingDone){
			this.intLoaded = false;
			this.extLoaded = false;
			this.envLoaded = false;
			this.camsLoaded = false;
			this.useSceneLoader = true;
			this.loadingDone = loadingDone;
		}

		LoadManager.prototype.check = function() {
			//console.log("Check Ext:",this.extLoaded,"Int:",this.intLoaded,"Env:",this.envLoaded,"Cams:",this.camsLoaded);
			if (!this.useSceneLoader || (this.intLoaded && this.extLoaded && this.envLoaded && this.camsLoaded)){
				this.loadingDone();
			}
		}
		
		getTextFromUrl(configURL, function (text) {
			try {
				config = JSON.parse(text);
				console.log("config loaded:", config);
				startRenderLoop();
			} catch (e) {
				console.error("JSON data of file " + configURL + " invalid", e);
			}
		});
		
    </script>
	
	<div id="ui-app"></div>
	<iframe src="http://localhost:8080/FBBVisualizer/" height="200" width="300" title="Iframe Example"></iframe>
   </body>

</html>